// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Compute.Batch
{
    /// <summary> The ComputeNodeExtension service client. </summary>
    public partial class ComputeNodeExtensionClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of ComputeNodeExtensionClient for mocking. </summary>
        protected ComputeNodeExtensionClient()
        {
        }

        /// <summary> Initializes a new instance of ComputeNodeExtensionClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal ComputeNodeExtensionClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, string batchUrl, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _batchUrl = batchUrl;
            _apiVersion = apiVersion;
        }

        /// <summary> Gets information about the specified Compute Node Extension. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName"> The name of the of the Compute Node Extension that you want to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetComputeNodeExtensionAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.GetComputeNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetComputeNodeExtensionAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.GetComputeNodeExtensionAsync("<poolId>", "<nodeId>", "<extensionName>", "<select>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>NodeVMExtension</c>:
        /// <code>{
        ///   provisioningState: string, # Optional. The provisioning state of the virtual machine extension.
        ///   vmExtension: {
        ///     name: string, # Required. The name of the virtual machine extension.
        ///     publisher: string, # Required. The name of the extension handler publisher.
        ///     type: string, # Required. The type of the extension.
        ///     typeHandlerVersion: string, # Optional. The version of script handler.
        ///     autoUpgradeMinorVersion: boolean, # Optional. Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        ///     settings: AnyObject, # Optional. JSON formatted public settings for the extension.
        ///     protectedSettings: AnyObject, # Optional. The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all. 
        ///     provisionAfterExtensions: [string], # Optional. Collection of extension names after which this extension needs to be provisioned.
        ///   }, # Optional. The configuration for virtual machine extensions.
        ///   instanceView: {
        ///     name: string, # Optional. The name of the vm extension instance view.
        ///     statuses: [
        ///       {
        ///         code: string, # Optional. The status code.
        ///         displayStatus: string, # Optional. The localized label for the status.
        ///         level: &quot;Error&quot; | &quot;Info&quot; | &quot;Warning&quot;, # Optional. Level code.
        ///         message: string, # Optional. The detailed status message.
        ///         time: string, # Optional. The time of the status.
        ///       }
        ///     ], # Optional. The resource status information.
        ///     subStatuses: [InstanceViewStatus], # Optional. The resource status information.
        ///   }, # Optional. The vm extension instance view.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetComputeNodeExtensionAsync(string poolId, string nodeId, string extensionName, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeExtensionClient.GetComputeNodeExtension");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetComputeNodeExtensionRequest(poolId, nodeId, extensionName, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node Extension. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName"> The name of the of the Compute Node Extension that you want to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetComputeNodeExtension with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.GetComputeNodeExtension("<poolId>", "<nodeId>", "<extensionName>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetComputeNodeExtension with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.GetComputeNodeExtension("<poolId>", "<nodeId>", "<extensionName>", "<select>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("provisioningState").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").ToString());
        /// Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>NodeVMExtension</c>:
        /// <code>{
        ///   provisioningState: string, # Optional. The provisioning state of the virtual machine extension.
        ///   vmExtension: {
        ///     name: string, # Required. The name of the virtual machine extension.
        ///     publisher: string, # Required. The name of the extension handler publisher.
        ///     type: string, # Required. The type of the extension.
        ///     typeHandlerVersion: string, # Optional. The version of script handler.
        ///     autoUpgradeMinorVersion: boolean, # Optional. Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        ///     settings: AnyObject, # Optional. JSON formatted public settings for the extension.
        ///     protectedSettings: AnyObject, # Optional. The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all. 
        ///     provisionAfterExtensions: [string], # Optional. Collection of extension names after which this extension needs to be provisioned.
        ///   }, # Optional. The configuration for virtual machine extensions.
        ///   instanceView: {
        ///     name: string, # Optional. The name of the vm extension instance view.
        ///     statuses: [
        ///       {
        ///         code: string, # Optional. The status code.
        ///         displayStatus: string, # Optional. The localized label for the status.
        ///         level: &quot;Error&quot; | &quot;Info&quot; | &quot;Warning&quot;, # Optional. Level code.
        ///         message: string, # Optional. The detailed status message.
        ///         time: string, # Optional. The time of the status.
        ///       }
        ///     ], # Optional. The resource status information.
        ///     subStatuses: [InstanceViewStatus], # Optional. The resource status information.
        ///   }, # Optional. The vm extension instance view.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetComputeNodeExtension(string poolId, string nodeId, string extensionName, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeExtensionClient.GetComputeNodeExtension");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetComputeNodeExtensionRequest(poolId, nodeId, extensionName, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Compute Nodes can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetComputeNodeExtensionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// await foreach (var data in client.GetComputeNodeExtensionsAsync("<poolId>", "<nodeId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetComputeNodeExtensionsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// await foreach (var data in client.GetComputeNodeExtensionsAsync("<poolId>", "<nodeId>", "<select>", 1234, 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>NodeVMExtensionListValue</c>:
        /// <code>{
        ///   provisioningState: string, # Optional. The provisioning state of the virtual machine extension.
        ///   vmExtension: {
        ///     name: string, # Required. The name of the virtual machine extension.
        ///     publisher: string, # Required. The name of the extension handler publisher.
        ///     type: string, # Required. The type of the extension.
        ///     typeHandlerVersion: string, # Optional. The version of script handler.
        ///     autoUpgradeMinorVersion: boolean, # Optional. Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        ///     settings: AnyObject, # Optional. JSON formatted public settings for the extension.
        ///     protectedSettings: AnyObject, # Optional. The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all. 
        ///     provisionAfterExtensions: [string], # Optional. Collection of extension names after which this extension needs to be provisioned.
        ///   }, # Optional. The configuration for virtual machine extensions.
        ///   instanceView: {
        ///     name: string, # Optional. The name of the vm extension instance view.
        ///     statuses: [
        ///       {
        ///         code: string, # Optional. The status code.
        ///         displayStatus: string, # Optional. The localized label for the status.
        ///         level: &quot;Error&quot; | &quot;Info&quot; | &quot;Warning&quot;, # Optional. Level code.
        ///         message: string, # Optional. The detailed status message.
        ///         time: string, # Optional. The time of the status.
        ///       }
        ///     ], # Optional. The resource status information.
        ///     subStatuses: [InstanceViewStatus], # Optional. The resource status information.
        ///   }, # Optional. The vm extension instance view.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetComputeNodeExtensionsAsync(string poolId, string nodeId, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            return GetComputeNodeExtensionsImplementationAsync("ComputeNodeExtensionClient.GetComputeNodeExtensions", poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
        }

        private AsyncPageable<BinaryData> GetComputeNodeExtensionsImplementationAsync(string diagnosticsScopeName, string poolId, string nodeId, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetComputeNodeExtensionsRequest(poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetComputeNodeExtensionsNextPageRequest(nextLink, poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Compute Nodes can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetComputeNodeExtensions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// foreach (var data in client.GetComputeNodeExtensions("<poolId>", "<nodeId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetComputeNodeExtensions with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetComputeNodeExtensionClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// foreach (var data in client.GetComputeNodeExtensions("<poolId>", "<nodeId>", "<select>", 1234, 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("provisioningState").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("publisher").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("type").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("typeHandlerVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("autoUpgradeMinorVersion").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("settings").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("protectedSettings").ToString());
        ///     Console.WriteLine(result.GetProperty("vmExtension").GetProperty("provisionAfterExtensions")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("displayStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("level").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("statuses")[0].GetProperty("time").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("displayStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("level").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("instanceView").GetProperty("subStatuses")[0].GetProperty("time").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>NodeVMExtensionListValue</c>:
        /// <code>{
        ///   provisioningState: string, # Optional. The provisioning state of the virtual machine extension.
        ///   vmExtension: {
        ///     name: string, # Required. The name of the virtual machine extension.
        ///     publisher: string, # Required. The name of the extension handler publisher.
        ///     type: string, # Required. The type of the extension.
        ///     typeHandlerVersion: string, # Optional. The version of script handler.
        ///     autoUpgradeMinorVersion: boolean, # Optional. Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        ///     settings: AnyObject, # Optional. JSON formatted public settings for the extension.
        ///     protectedSettings: AnyObject, # Optional. The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all. 
        ///     provisionAfterExtensions: [string], # Optional. Collection of extension names after which this extension needs to be provisioned.
        ///   }, # Optional. The configuration for virtual machine extensions.
        ///   instanceView: {
        ///     name: string, # Optional. The name of the vm extension instance view.
        ///     statuses: [
        ///       {
        ///         code: string, # Optional. The status code.
        ///         displayStatus: string, # Optional. The localized label for the status.
        ///         level: &quot;Error&quot; | &quot;Info&quot; | &quot;Warning&quot;, # Optional. Level code.
        ///         message: string, # Optional. The detailed status message.
        ///         time: string, # Optional. The time of the status.
        ///       }
        ///     ], # Optional. The resource status information.
        ///     subStatuses: [InstanceViewStatus], # Optional. The resource status information.
        ///   }, # Optional. The vm extension instance view.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetComputeNodeExtensions(string poolId, string nodeId, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            return GetComputeNodeExtensionsImplementation("ComputeNodeExtensionClient.GetComputeNodeExtensions", poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
        }

        private Pageable<BinaryData> GetComputeNodeExtensionsImplementation(string diagnosticsScopeName, string poolId, string nodeId, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetComputeNodeExtensionsRequest(poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetComputeNodeExtensionsNextPageRequest(nextLink, poolId, nodeId, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateGetComputeNodeExtensionRequest(string poolId, string nodeId, string extensionName, string select, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/extensions/", false);
            uri.AppendPath(extensionName, true);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetComputeNodeExtensionsRequest(string poolId, string nodeId, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/extensions", false);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetComputeNodeExtensionsNextPageRequest(string nextLink, string poolId, string nodeId, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
