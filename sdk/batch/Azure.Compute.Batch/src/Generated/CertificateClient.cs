// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Compute.Batch
{
    /// <summary> The Certificate service client. </summary>
    public partial class CertificateClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of CertificateClient for mocking. </summary>
        protected CertificateClient()
        {
        }

        /// <summary> Initializes a new instance of CertificateClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal CertificateClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, string batchUrl, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _batchUrl = batchUrl;
            _apiVersion = apiVersion;
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call AddAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// var data = new {
        ///     thumbprint = "<thumbprint>",
        ///     thumbprintAlgorithm = "<thumbprintAlgorithm>",
        ///     data = "<data>",
        /// };
        /// 
        /// Response response = await client.AddAsync(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call AddAsync with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// var data = new {
        ///     thumbprint = "<thumbprint>",
        ///     thumbprintAlgorithm = "<thumbprintAlgorithm>",
        ///     data = "<data>",
        ///     certificateFormat = "pfx",
        ///     password = "<password>",
        /// };
        /// 
        /// Response response = await client.AddAsync(RequestContent.Create(data), 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CertificateAddParameter</c>:
        /// <code>{
        ///   thumbprint: string, # Required. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits (it may include spaces but these are removed).
        ///   thumbprintAlgorithm: string, # Required. The algorithm used to derive the thumbprint. This must be sha1.
        ///   data: string, # Required. The base64-encoded contents of the Certificate. The maximum size is 10KB.
        ///   certificateFormat: &quot;pfx&quot; | &quot;cer&quot;, # Optional. The format of the Certificate data.
        ///   password: string, # Optional. This must be omitted if the Certificate format is cer.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddAsync(RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call Add with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// var data = new {
        ///     thumbprint = "<thumbprint>",
        ///     thumbprintAlgorithm = "<thumbprintAlgorithm>",
        ///     data = "<data>",
        /// };
        /// 
        /// Response response = client.Add(RequestContent.Create(data));
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call Add with all parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// var data = new {
        ///     thumbprint = "<thumbprint>",
        ///     thumbprintAlgorithm = "<thumbprintAlgorithm>",
        ///     data = "<data>",
        ///     certificateFormat = "pfx",
        ///     password = "<password>",
        /// };
        /// 
        /// Response response = client.Add(RequestContent.Create(data), 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>CertificateAddParameter</c>:
        /// <code>{
        ///   thumbprint: string, # Required. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits (it may include spaces but these are removed).
        ///   thumbprintAlgorithm: string, # Required. The algorithm used to derive the thumbprint. This must be sha1.
        ///   data: string, # Required. The base64-encoded contents of the Certificate. The maximum size is 10KB.
        ///   certificateFormat: &quot;pfx&quot; | &quot;cer&quot;, # Optional. The format of the Certificate data.
        ///   password: string, # Optional. This must be omitted if the Certificate format is cer.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Add(RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancels a failed deletion of a Certificate from the specified Account. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CancelDeletionAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.CancelDeletionAsync("<thumbprintAlgorithm>", "<thumbprint>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CancelDeletionAsync with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.CancelDeletionAsync("<thumbprintAlgorithm>", "<thumbprint>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </remarks>
        public virtual async Task<Response> CancelDeletionAsync(string thumbprintAlgorithm, string thumbprint, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.CancelDeletion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Cancels a failed deletion of a Certificate from the specified Account. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CancelDeletion with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.CancelDeletion("<thumbprintAlgorithm>", "<thumbprint>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CancelDeletion with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.CancelDeletion("<thumbprintAlgorithm>", "<thumbprint>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </remarks>
        public virtual Response CancelDeletion(string thumbprintAlgorithm, string thumbprint, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.CancelDeletion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a Certificate from the specified Account. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.DeleteAsync("<thumbprintAlgorithm>", "<thumbprint>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call DeleteAsync with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.DeleteAsync("<thumbprintAlgorithm>", "<thumbprint>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </remarks>
        public virtual async Task<Response> DeleteAsync(string thumbprintAlgorithm, string thumbprint, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a Certificate from the specified Account. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call Delete with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.Delete("<thumbprintAlgorithm>", "<thumbprint>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call Delete with all parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.Delete("<thumbprintAlgorithm>", "<thumbprint>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        /// <remarks> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </remarks>
        public virtual Response Delete(string thumbprintAlgorithm, string thumbprint, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCertificateAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.GetCertificateAsync("<thumbprintAlgorithm>", "<thumbprint>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetCertificateAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = await client.GetCertificateAsync("<thumbprintAlgorithm>", "<thumbprint>", "<select>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("thumbprint").ToString());
        /// Console.WriteLine(result.GetProperty("thumbprintAlgorithm").ToString());
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("state").ToString());
        /// Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
        /// Console.WriteLine(result.GetProperty("previousState").ToString());
        /// Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
        /// Console.WriteLine(result.GetProperty("publicData").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Certificate</c>:
        /// <code>{
        ///   thumbprint: string, # Optional. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits.
        ///   thumbprintAlgorithm: string, # Optional. The algorithm used to derive the thumbprint.
        ///   url: string, # Optional. The URL of the Certificate.
        ///   state: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. The state of the Certificate.
        ///   stateTransitionTime: string (ISO 8601 Format), # Optional. The time at which the Certificate entered its current state.
        ///   previousState: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. This property is not set if the Certificate is in its initial active state.
        ///   previousStateTransitionTime: string (ISO 8601 Format), # Optional. This property is not set if the Certificate is in its initial Active state.
        ///   publicData: string, # Optional. The public part of the Certificate as a base-64 encoded .cer file.
        ///   deleteCertificateError: {
        ///     code: string, # Optional. An identifier for the Certificate deletion error. Codes are invariant and are intended to be consumed programmatically.
        ///     message: string, # Optional. A message describing the Certificate deletion error, intended to be suitable for display in a user interface.
        ///     values: [
        ///       {
        ///         name: string, # Optional. The name in the name-value pair.
        ///         value: string, # Optional. The value in the name-value pair.
        ///       }
        ///     ], # Optional. This list includes details such as the active Pools and Compute Nodes referencing this Certificate. However, if a large number of resources reference the Certificate, the list contains only about the first hundred.
        ///   }, # Optional. This property is set only if the Certificate is in the DeleteFailed state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetCertificateAsync(string thumbprintAlgorithm, string thumbprint, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.GetCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificateRequest(thumbprintAlgorithm, thumbprint, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCertificate with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.GetCertificate("<thumbprintAlgorithm>", "<thumbprint>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.ToString());
        /// ]]></code>
        /// This sample shows how to call GetCertificate with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// Response response = client.GetCertificate("<thumbprintAlgorithm>", "<thumbprint>", "<select>", 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("thumbprint").ToString());
        /// Console.WriteLine(result.GetProperty("thumbprintAlgorithm").ToString());
        /// Console.WriteLine(result.GetProperty("url").ToString());
        /// Console.WriteLine(result.GetProperty("state").ToString());
        /// Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
        /// Console.WriteLine(result.GetProperty("previousState").ToString());
        /// Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
        /// Console.WriteLine(result.GetProperty("publicData").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("value").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Certificate</c>:
        /// <code>{
        ///   thumbprint: string, # Optional. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits.
        ///   thumbprintAlgorithm: string, # Optional. The algorithm used to derive the thumbprint.
        ///   url: string, # Optional. The URL of the Certificate.
        ///   state: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. The state of the Certificate.
        ///   stateTransitionTime: string (ISO 8601 Format), # Optional. The time at which the Certificate entered its current state.
        ///   previousState: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. This property is not set if the Certificate is in its initial active state.
        ///   previousStateTransitionTime: string (ISO 8601 Format), # Optional. This property is not set if the Certificate is in its initial Active state.
        ///   publicData: string, # Optional. The public part of the Certificate as a base-64 encoded .cer file.
        ///   deleteCertificateError: {
        ///     code: string, # Optional. An identifier for the Certificate deletion error. Codes are invariant and are intended to be consumed programmatically.
        ///     message: string, # Optional. A message describing the Certificate deletion error, intended to be suitable for display in a user interface.
        ///     values: [
        ///       {
        ///         name: string, # Optional. The name in the name-value pair.
        ///         value: string, # Optional. The value in the name-value pair.
        ///       }
        ///     ], # Optional. This list includes details such as the active Pools and Compute Nodes referencing this Certificate. However, if a large number of resources reference the Certificate, the list contains only about the first hundred.
        ///   }, # Optional. This property is set only if the Certificate is in the DeleteFailed state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetCertificate(string thumbprintAlgorithm, string thumbprint, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("CertificateClient.GetCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificateRequest(thumbprintAlgorithm, thumbprint, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Certificates can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCertificatesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// await foreach (var data in client.GetCertificatesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCertificatesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// await foreach (var data in client.GetCertificatesAsync("<filter>", "<select>", 1234, 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("thumbprint").ToString());
        ///     Console.WriteLine(result.GetProperty("thumbprintAlgorithm").ToString());
        ///     Console.WriteLine(result.GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("state").ToString());
        ///     Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
        ///     Console.WriteLine(result.GetProperty("previousState").ToString());
        ///     Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
        ///     Console.WriteLine(result.GetProperty("publicData").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("value").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CertificateListResultValue</c>:
        /// <code>{
        ///   thumbprint: string, # Optional. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits.
        ///   thumbprintAlgorithm: string, # Optional. The algorithm used to derive the thumbprint.
        ///   url: string, # Optional. The URL of the Certificate.
        ///   state: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. The state of the Certificate.
        ///   stateTransitionTime: string (ISO 8601 Format), # Optional. The time at which the Certificate entered its current state.
        ///   previousState: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. This property is not set if the Certificate is in its initial active state.
        ///   previousStateTransitionTime: string (ISO 8601 Format), # Optional. This property is not set if the Certificate is in its initial Active state.
        ///   publicData: string, # Optional. The public part of the Certificate as a base-64 encoded .cer file.
        ///   deleteCertificateError: {
        ///     code: string, # Optional. An identifier for the Certificate deletion error. Codes are invariant and are intended to be consumed programmatically.
        ///     message: string, # Optional. A message describing the Certificate deletion error, intended to be suitable for display in a user interface.
        ///     values: [
        ///       {
        ///         name: string, # Optional. The name in the name-value pair.
        ///         value: string, # Optional. The value in the name-value pair.
        ///       }
        ///     ], # Optional. This list includes details such as the active Pools and Compute Nodes referencing this Certificate. However, if a large number of resources reference the Certificate, the list contains only about the first hundred.
        ///   }, # Optional. This property is set only if the Certificate is in the DeleteFailed state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetCertificatesAsync(string filter = null, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return GetCertificatesImplementationAsync("CertificateClient.GetCertificates", filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
        }

        private AsyncPageable<BinaryData> GetCertificatesImplementationAsync(string diagnosticsScopeName, string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCertificatesRequest(filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetCertificatesNextPageRequest(nextLink, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Certificates can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetCertificates and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// foreach (var data in client.GetCertificates())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetCertificates with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var client = new BatchClient(credential).GetCertificateClientClient("<batchUrl>", <2022-01-01.15.0>);
        /// 
        /// foreach (var data in client.GetCertificates("<filter>", "<select>", 1234, 1234, Guid.NewGuid(), true, DateTimeOffset.UtcNow))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("thumbprint").ToString());
        ///     Console.WriteLine(result.GetProperty("thumbprintAlgorithm").ToString());
        ///     Console.WriteLine(result.GetProperty("url").ToString());
        ///     Console.WriteLine(result.GetProperty("state").ToString());
        ///     Console.WriteLine(result.GetProperty("stateTransitionTime").ToString());
        ///     Console.WriteLine(result.GetProperty("previousState").ToString());
        ///     Console.WriteLine(result.GetProperty("previousStateTransitionTime").ToString());
        ///     Console.WriteLine(result.GetProperty("publicData").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deleteCertificateError").GetProperty("values")[0].GetProperty("value").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>CertificateListResultValue</c>:
        /// <code>{
        ///   thumbprint: string, # Optional. The X.509 thumbprint of the Certificate. This is a sequence of up to 40 hex digits.
        ///   thumbprintAlgorithm: string, # Optional. The algorithm used to derive the thumbprint.
        ///   url: string, # Optional. The URL of the Certificate.
        ///   state: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. The state of the Certificate.
        ///   stateTransitionTime: string (ISO 8601 Format), # Optional. The time at which the Certificate entered its current state.
        ///   previousState: &quot;active&quot; | &quot;deleting&quot; | &quot;deletefailed&quot;, # Optional. This property is not set if the Certificate is in its initial active state.
        ///   previousStateTransitionTime: string (ISO 8601 Format), # Optional. This property is not set if the Certificate is in its initial Active state.
        ///   publicData: string, # Optional. The public part of the Certificate as a base-64 encoded .cer file.
        ///   deleteCertificateError: {
        ///     code: string, # Optional. An identifier for the Certificate deletion error. Codes are invariant and are intended to be consumed programmatically.
        ///     message: string, # Optional. A message describing the Certificate deletion error, intended to be suitable for display in a user interface.
        ///     values: [
        ///       {
        ///         name: string, # Optional. The name in the name-value pair.
        ///         value: string, # Optional. The value in the name-value pair.
        ///       }
        ///     ], # Optional. This list includes details such as the active Pools and Compute Nodes referencing this Certificate. However, if a large number of resources reference the Certificate, the list contains only about the first hundred.
        ///   }, # Optional. This property is set only if the Certificate is in the DeleteFailed state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetCertificates(string filter = null, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return GetCertificatesImplementation("CertificateClient.GetCertificates", filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
        }

        private Pageable<BinaryData> GetCertificatesImplementation(string diagnosticsScopeName, string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetCertificatesRequest(filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetCertificatesNextPageRequest(nextLink, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateAddRequest(RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetCertificatesRequest(string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCancelDeletionRequest(string thumbprintAlgorithm, string thumbprint, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")/canceldelete", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string thumbprintAlgorithm, string thumbprint, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCertificateRequest(string thumbprintAlgorithm, string thumbprint, string select, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetCertificatesNextPageRequest(string nextLink, string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
    }
}
